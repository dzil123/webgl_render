{"version":3,"file":"gltf.js","sourceRoot":"","sources":["../../src/gltf.ts"],"names":[],"mappings":"AACA,OAAO,KAAK,IAAI,MAAM,WAAW,CAAC;AAoElC,KAAK,UAAU,cAAc,CAAC,MAAc;IAC1C,IAAI,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC;IACnC,IAAI,IAAI,GAAG,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,GAAG,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;IACvE,IAAI,IAAI,CAAC,UAAU,IAAI,MAAM,CAAC,UAAU,EAAE;QACxC,MAAM,EAAE,GAAG,EAAE,oBAAoB,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC;KACnD;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED,SAAS,cAAc,CACrB,EAAa,EACb,UAAsB,EACtB,OAAsB;IAEtB,IAAI,UAAU,CAAC,UAAU,KAAK,SAAS,EAAE;QACvC,MAAM,wBAAwB,CAAC;KAChC;IAED,IAAI,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC;IACrD,IAAI,MAAM,GAAG,UAAU,CAAC,UAAU,IAAI,CAAC,CAAC;IACxC,IAAI,MAAM,GAAG,IAAI,CAAC,OAAO,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;IAE7C,0DAA0D;IAC1D,IAAI,SAAS,GAAG,IAAI,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,UAAU,CAAC,UAAU,CAAC,CAAC;IAErE,IAAI,QAAQ,GAAG,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,YAAY,EAAE,CAAC,CAAC;IAC/C,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,QAAQ,CAAC,CAAC;IAChC,EAAE,CAAC,UAAU,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,CAAC,WAAW,CAAC,CAAC;IAEjD,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,MAAM,EAAE,CAAC;AACzC,CAAC;AAED,MAAM,CAAC,KAAK,UAAU,QAAQ,CAAC,EAAa,EAAE,IAAY;IACxD,IAAI,IAAI,GAAS,MAAM,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC;IACvE,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClB,IAAI,IAAI,CAAC,KAAK,CAAC,OAAO,KAAK,KAAK,EAAE;QAChC,MAAM,EAAE,GAAG,EAAE,kBAAkB,EAAE,KAAK,EAAE,IAAI,CAAC,KAAK,EAAE,CAAC;KACtD;IAED,IAAI,CAAC,OAAO,GAAG,IAAI,CAAC,OAAO,IAAI,EAAE,CAAC;IAClC,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,IAAI,EAAE,CAAC;IAE1C,IAAI,OAAO,GAAG,MAAM,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC;IAClE,IAAI,WAAW,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,cAAc,CAAC,EAAE,EAAE,CAAC,EAAE,OAAO,CAAC,CAAC,CAAC;IAE9E,IAAI,KAAK,GAAG,EAAE,OAAO,EAAE,WAAW,EAAE,CAAC;IAErC,OAAO,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;AACvB,CAAC","sourcesContent":["import * as webgl from \"./webgl.js\";\nimport * as util from \"./util.js\";\n\ninterface Gltf {\n  asset: { version: \"2.0\" };\n  buffers?: Buffer[];\n  meshes?: Mesh[];\n  accessors?: Accessor[];\n  bufferViews?: BufferView[];\n}\n\nconst enum AccessorTypeEnum {\n  SCALAR,\n  VEC2,\n  VEC3,\n  MAT2,\n  MAT3,\n  MAT4,\n}\ntype AccessorType = keyof typeof AccessorTypeEnum;\n\ninterface Accessor {\n  bufferView?: number; // -> bufferViews\n  byteOffset?: number;\n  componentType: webgl.GL.ArrayType | webgl.GL.GLenum<\"UNSIGNED_INT\">;\n  count: number;\n  type: AccessorType;\n}\n\n// @ts-ignore\n// let x: Accessor = null;\n\n// if (x.type == AccessorType[\"MAT2\"]) {\n// }\n\ninterface BufferView {\n  buffer: number; // -> buffers\n  byteOffset?: number;\n  byteLength: number;\n  byteStride?: number;\n  target?: webgl.GL.BufferTarget;\n}\n\ninterface Buffer {\n  uri?: string;\n  byteLength: number;\n}\n\ninterface Mesh {\n  primitives: Primitive[];\n}\n\ninterface Primitive {\n  attributes: { [key: string]: number }; // -> accessors\n  indices?: number; // -> accessors\n  mode?: webgl.GL.DrawMode;\n}\n\ninterface Scene {\n  buffers: ArrayBuffer[];\n  bufferViews: SceneBufferViews[];\n}\n\ninterface SceneBufferViews {\n  arrayView: BufferSource;\n  glBuffer: WebGLBuffer;\n  target: webgl.GL.BufferTarget;\n}\n\nasync function downloadBuffer(buffer: Buffer): Promise<ArrayBuffer> {\n  let uri = util.nonnull(buffer.uri);\n  let data = await util.download(\"models/\", uri, (r) => r.arrayBuffer());\n  if (data.byteLength != buffer.byteLength) {\n    throw { msg: \"Size doesn't match\", data, buffer };\n  }\n  return data;\n}\n\nfunction loadBufferView(\n  gl: webgl.GL2,\n  bufferView: BufferView,\n  buffers: ArrayBuffer[]\n): SceneBufferViews {\n  if (bufferView.byteStride !== undefined) {\n    throw \"byteStride unsupported\";\n  }\n\n  let array = util.nonnull(buffers[bufferView.buffer]);\n  let offset = bufferView.byteOffset || 0;\n  let target = util.nonnull(bufferView.target);\n\n  // TODO: is it ok to use Uint8 regardless of AccessorType?\n  let arrayView = new Uint8Array(array, offset, bufferView.byteLength);\n\n  let glBuffer = util.nonnull(gl.createBuffer());\n  gl.bindBuffer(target, glBuffer);\n  gl.bufferData(target, arrayView, gl.STATIC_DRAW);\n\n  return { arrayView, glBuffer, target };\n}\n\nexport async function loadGltf(gl: webgl.GL2, name: string): Promise<[Gltf, Scene]> {\n  let gltf: Gltf = await util.download(\"models/\", name, (r) => r.json());\n  console.dir(gltf);\n  if (gltf.asset.version !== \"2.0\") {\n    throw { msg: \"Unsupported gltf\", asset: gltf.asset };\n  }\n\n  gltf.buffers = gltf.buffers || [];\n  gltf.bufferViews = gltf.bufferViews || [];\n\n  let buffers = await Promise.all(gltf.buffers.map(downloadBuffer));\n  let bufferViews = gltf.bufferViews.map((v) => loadBufferView(gl, v, buffers));\n\n  let scene = { buffers, bufferViews };\n\n  return [gltf, scene];\n}\n"]}