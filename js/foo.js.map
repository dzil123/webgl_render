{"version":3,"file":"foo.js","sourceRoot":"","sources":["../../src/foo.ts"],"names":[],"mappings":"AAAA,MAAM,CAAC,IAAI,GAAG,GAAG,CAAC,CAAC;AAiRnB;IACE,SAAS,QAAQ,CAAC,CAAQ,IAAG,CAAC;IAE9B,IAAI,KAAK,GAAkB,EAAE,GAAG,EAAE,EAAE,EAAW,CAAC;IAChD,KAAK,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,EAAE,EAAW,CAAC;IACvC,KAAK,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,EAAE,EAAW,CAAC;IACvC,QAAQ,CAAC,KAAK,CAAC,CAAC;CACjB;AAuED;;;;;EAKE;AAEF,SAAS,GAAG;IACV,IAAI,KAAK,GAAkC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC;IACvD,kBAAkB;IAClB,KAAK,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC;IAC9B,KAAK,GAAG,EAAE,GAAG,KAAK,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC;IAC9B,6BAA6B;AAC/B,CAAC;AACD,IAAI;AACJ,uEAAuE;AACvE,cAAc;AACd,uBAAuB;AACvB,eAAe;AACf,UAAU;AACV,eAAe;AAEf,8BAA8B;AAC9B,IAAI","sourcesContent":["export let foo = 1;\n\ninterface Scene {\n  foo: {};\n  bar: {};\n  baz: {};\n}\n\n// oh boy don't do this\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n  k: infer I\n) => void\n  ? I\n  : never;\ntype LastOf<T> = UnionToIntersection<\n  T extends any ? () => T : never\n> extends () => infer R\n  ? R\n  : never;\n\n// TS4.0+\ntype Push<T extends any[], V> = [...T, V];\n\n// TS4.1+\ntype TuplifyUnion<\n  T,\n  L = LastOf<T>,\n  N = [T] extends [never] ? true : false\n> = true extends N ? [] : Push<TuplifyUnion<Exclude<T, L>>, L>;\n\n// type Partial<T> = never;\n\n// type Foo__ = TuplifyUnion<keyof Scene>;\n\ntype PartialScene =\n  | Partial<Scene>\n  | (Partial<Scene> & Pick<Scene, \"foo\">)\n  | (Partial<Scene> & Pick<Scene, \"foo\" | \"bar\">)\n  | (Partial<Scene> & Pick<Scene, \"foo\" | \"bar\" | \"baz\">);\n// | (Partial<Scene> & Pick<Scene, \"foo\" | \"bar\" | \"baz\" | \"qux\">);\n\ntype PartialScene2 =\n  | Pick<Scene, \"foo\">\n  | Pick<Scene, \"foo\" | \"bar\">\n  | Pick<Scene, \"foo\" | \"bar\" | \"baz\">;\n\ntype PartialScene3 =\n  | Pick<Scene, \"foo\">\n  | Pick<Scene, \"bar\">\n  | Pick<Scene, \"baz\">\n  | Pick<Scene, \"foo\" | \"bar\">\n  | Pick<Scene, \"foo\" | \"baz\">\n  | Pick<Scene, \"bar\" | \"baz\">\n  | Pick<Scene, \"foo\" | \"bar\" | \"baz\">;\n\n// | Pick<Scene, \"foo\" | \"bar\" | \"baz\" | \"qux\">;\n\ntype PowerSet<T, F extends (keyof T)[]> = F[\"length\"] extends 0\n  ? number\n  : boolean;\n// type X = Expand<PowerSet<keyof \"\">>;\n// type X1 = ExpandRecursively<PowerSet<keyof \"\">>;\n\n// type X = Expand<TuplifyUnion<keyof Scene>>;\n// type X = Expand<LastOf<keyof {}>>;\n\n// function powerset(x: number[], y: number[] = []): number[][] {\n//   if (x.length == 0) {\n//   } else {\n//     let first = x[-1] as number;\n//     let rest = x.pop();\n//     let pt = powerset(rest);\n\n//   }\n\n// type AppendToAll<T,\n\n//   throw \"\";\n// }\n\n// type XX<T> = LastOf<T> extends never ? [] : [1, ...XX<Exclude<T, LastOf<T>>>];\ntype XX<T, U> = LastOf<U> extends never\n  ? never\n  : XX<T, Exclude<U, LastOf<U>>> | Foo<T, LastOf<U>>;\n\n// [ Foo<T, X> for X in List ]\ntype ApplyFoo<T, List> = LastOf<List> extends never\n  ? never\n  : ApplyFoo<T, PopLast<List>> | Foo<T, LastOf<List>>;\n\ntype Foo<T, U> = [T | U];\n\ntype NotEmpty<List, T> = LastOf<List> extends never ? never : T; // for reference, cant actually use\ntype PopLast<List> = Exclude<List, LastOf<List>>;\n\n// type ApplyFoo<Param, List> = NotEmpty<\n//   List,\n//   ApplyFoo<Param, Exclude<List, LastOf<List>>> | Foo<Param, LastOf<List>>\n// >;\n\n// type _A<T> = _B<T, {}, keyof T>;\n// type _B<T, R, L extends keyof T> = LastOf<L> extends never\n//   ? R\n//   : _B<T, R, PopLast<L>> | _C<T, LastOf<L>, _B<T, R, PopLast<L>>>;\n// type _C<T, X extends keyof T, R> = LastOf<R> extends never\n//   ? never\n//   : _C<T, X, PopLast<R>> | PopLast<R> | Pick<T, X>;\n\n// type K = TuplifyUnion<keyof Scene>;\ntype K_ = ExpandRecursively<(keyof Scene)[]>;\n\ntype List<T, L extends T[]> = L extends [infer First extends T, ...infer Rest]\n  ? [First, Rest]\n  : never;\n\n// type Head<T, L extends (keyof T)[]> = List<T, L>[0];\n// type Tail<T, L extends (keyof T)[]> = List<T, L>[1];\n\ntype LenMinus1<L extends unknown[]> = L extends [L[number], ...infer Rest]\n  ? Rest[\"length\"]\n  : never;\n\ntype Tuple<TItem, TLength extends number> = [TItem, ...TItem[]] & {\n  length: TLength;\n};\n\ntype Sub1<N extends number> = LenMinus1<Tuple<never, N>>;\n\n// type List<L extends unknown[]> = L extends [\n//   infer First extends L[number],\n//   ...(infer Rest & Tuple<L[number], LenMinus1<L>>)\n// ]\n//   ? // ? { first: First; rest: Rest }\n//     [First, Rest]\n//   : never;\n\n// type Head<T, L extends T[]> = List<T, L>[0];\n// type Tail<T, L extends T[]> = List<T, L>[1];\n\n// type ListA<T, L extends (keyof T)[]> = List<keyof T, L>;\n// type ListB<T, L extends Partial<T>[]> = List<Partial<T>, L>;\n\n// type HeadA<T, L extends (keyof T)[]> = List<L>[0];\n// type TailA<T, L extends (keyof T)[]> = List<L>[1];\n\n// type HeadB<T, L extends Partial<T>[]> = List<L>[0];\n// type TailB<T, L extends Partial<T>[]> = List<L>[1];\n\n// type HeadA<T, L extends (keyof T)[]> = List<keyof T, L>[0];\n// type TailA<T, L extends (keyof T)[]> = List<keyof T, L>[1];\n\n// type HeadB<T, L extends Partial<T>[]> = List<Partial<T>, L>[0];\n// type TailB<T, L extends Partial<T>[]> = List<Partial<T>, L>[1];\n\ntype HeadPrime<T extends unknown[]> = ((...args: T) => never) extends (\n  _: infer R,\n  ...args: any\n) => never\n  ? R\n  : never;\n\ntype TailPrime<T extends unknown[]> = ((...args: T) => never) extends (\n  _: any,\n  ...args: infer R\n) => never\n  ? R\n  : never;\n\ntype Head<T extends unknown[]> = T[\"length\"] extends 0 ? never : HeadPrime<T>;\ntype Tail<T extends unknown[]> = T[\"length\"] extends 0 ? never : TailPrime<T>;\n\ntype HeadA<T, L extends (keyof T)[]> = Head<L>;\ntype TailA<T, L extends (keyof T)[]> = Tail<L>;\n\ntype HeadB<T, L extends Partial<T>[]> = Head<L>;\ntype TailB<T, L extends Partial<T>[]> = Tail<L>;\n\ntype ListToUnion<T extends unknown[]> = T[number];\n\n// type _A<T, K extends (keyof T)[]> = _B<T, {}, K>;\n\n// type _B<T, R extends Partial<T>[], L extends (keyof T)[]> = HeadA<\n//   T,\n//   L\n// > extends never\n//   ? R\n//   : _B<T, R, TailA<T, L>> | _C<T, HeadA<T, L>, _B<T, R, TailA<T, L>>>;\n// // : [_B<T, R, TailA<T, L>>, ..._C<T, HeadA<T, L>, _B<T, R, TailA<T, L>>>];\n\n// type _C<T, X extends keyof T, R extends Partial<T>[]> = HeadB<\n//   T,\n//   R\n// > extends never\n//   ? never\n//   : // : _C<T, X, TailB<T, R>> | (ListToUnion<TailB<T, R>> & Pick<T, X>);\n//     _C<T, X, TailB<T, R>> | _D<TailB<T, R>, Pick<T, X>>;\n\n// type _D<T extends unknown[], X> = T[\"length\"] extends 0\n//   ? X\n//   : ListToUnion<T> & X;\n\n// : ListToUnion<TailB<T, R>> & Pick<T, X>;\n\n// type _C<T, X extends keyof T, R extends (keyof T)[]> = R[\"length\"] extends 0\n//   ? [X]\n//   : // : [_D<Tail<R>, X>, ..._C<T, X, Tail<R>>];\n//     // [ListToUnion<Tail<R>> | X, ..._C<T, X, Tail<R>>];\n//     [Head<R> | X, ..._C<T, X, Tail<R>>];\n\n// type _A<T, K extends T[]> = _B<T, [], K>;\n\n// type _B<T, R extends T[], L extends T[]> = L[\"length\"] extends 0\n//   ? R\n//   : [..._B<T, R, Tail<L>>, ..._C<T, Head<L>, _B<T, R, Tail<L>>>];\n// // // : _B<T, R, Tail<L>> | _C<T, Head<L>, _B<T, R, Tail<L>>>;\n\n// type _B<T, L extends (keyof T)[], N extends number[]> = N[\"length\"] extends 0\n//   ? L\n//   : L[\"length\"] extends 0\n//   ? []\n//   : _B<T, Tail<L>, Tail<N>> extends infer _B2 | (keyof T)[]\n//   ? [..._B2]\n//   : [];\n\ntype ForEachPick<T, L extends (keyof T)[]> = L[\"length\"] extends 0\n  ? never\n  : Pick<T, Head<L>> | ForEachPick<T, Tail<L>>;\n\ntype _A<T, L extends (keyof T)[]> = ForEachPick<T, _B<keyof T, L>>;\n\ntype _B<T, L extends T[]> = L[\"length\"] extends 0\n  ? []\n  : _B<T, Tail<L>> extends infer _B2\n  ? _B2 extends T[]\n    ? [..._B2, ..._C<T, Head<L>, _B2>]\n    : []\n  : [];\n\ntype _C<T, X extends T, R extends T[]> = R[\"length\"] extends 0\n  ? [X]\n  : [Head<R> | X, ..._C<T, X, Tail<R>>];\n\n// type _D<T extends unknown[], X> = T[\"length\"] extends 0\n//   ? X\n//   : ListToUnion<T> | X;\n\n// type X = _C<any, \"foo\", [\"qux\", \"bar\", \"baz\"]>;\n// type X0 = [];\n// type X1 = [...X0, ..._C<any, \"foo\", []>];\n// type X2 = [...X1, ..._C<any, \"bar\", X1>];\n// type X3 = [...X2, ..._C<any, \"baz\", X2>];\n// type X = X3;\n// type X = _B<any, [\"foo\", \"bar\", \"baz\"], [1, 2, 3, 4]>;\n// type X = _B<any, [1, 2]>;\n// type X = _A<any, [1, 2]>;\n// type X = _A<Scene, [\"foo\", \"bar\", \"baz\"]>;\ntype X = Builder2<Scene, [\"foo\", \"bar\", \"baz\"]>;\n// type X = _C2<Scene, [\"foo\", \"bar\", \"baz\"]>;\ntype X_ = Expand<X>;\n\ntype Builder2<T, L extends (keyof T)[]> = L[\"length\"] extends 0\n  ? never\n  : Builder2<T, Tail<L>> | _C2<T, L>;\n\ntype _C2<T, L extends (keyof T)[]> = L[\"length\"] extends 1\n  ? Pick<T, Head<L>>\n  : Pick<T, Head<L>> & _C2<T, Tail<L>>;\n\ntype _C3<T, L extends (keyof T)[]> = Pick<T, L[number]>;\n\ntype AAA = Expand<_C2<Scene, [\"foo\", \"bar\"]>>;\ntype AAA2 = Expand<_C2<Scene, [\"foo\", \"bar\"]>>;\n\n{\n  function useScene(_: Scene) {}\n\n  let scene: PartialScene3 = { foo: {} } as const;\n  scene = { ...scene, bar: {} } as const;\n  scene = { ...scene, baz: {} } as const;\n  useScene(scene);\n}\n\n// type X = _D<[\"foo\", \"bar\"], \"baz\">;\n// type X = ListToUnion<[]>;\n// type X1 = Expand<List<number, []>>;\n// type X2 = Expand<Head<[]>>;\n// type X = Expand<LenMinus1<[1]>>;\n// type X = X_<[5, 6, 7, 8]>;\n// type X = ListToUnion<[5, 6, 7, 8]>;\n// type X1 = Pick<Scene, \"baz\" | \"foo\">;\n// type X2 = Expand<Pick<Scene, \"baz\"> | Pick<Scene, \"foo\">>;\n\n// {\n//   type foo = Pick<Scene, \"foo\">;\n//   type bar = Pick<Scene, \"bar\">;\n//   type baz = Pick<Scene, \"baz\">;\n\n//   type X =\n//     | never\n//     | foo\n//     | bar\n//     | baz\n//     | (foo & bar)\n//     | (foo & baz)\n//     | (bar & baz)\n//     | (foo & bar & baz);\n//   type X_ = Expand<X>;\n\n//   type Y = _D<[bar, baz], foo>;\n//   type Y_ = Expand<Y>;\n// }\n\n// type X_<L extends unknown[]> = Tuple<L[number], LenMinus1<L>>;\n\n// type X = () [P in keyof Scene]: number }\n\n// type X = keyof {[P in keyof Scene as Pick<Scene, P>]: never};\n\n// type _Foo = Expand<_A<Scene, [\"foo\", \"bar\", \"baz\"]>>;\n// type _Foo = Expand<Head<Scene, [\"foo\", \"bar\", \"baz\"]>>;\n// type _Foo = Expand<Tail<Scene, [\"foo\", \"bar\", \"baz\"]>>;\n// type _Foo = ExpandRecursively<_C<Scene, \"foo\", [\"bar\", \"baz\"]>>;\n\n// type K2 = _A<Scene>;\n\n// type foo = ExpandRecursively<PowerSet<Scene>>;\n\ntype Test = Pick<Scene, \"foo\"> | Pick<Scene, \"foo\" | \"bar\">;\n\ntype DoesExtend<A, B> = A extends B ? true : false;\n\ntype F = DoesExtend<[1], []>;\n\nimport { Builder } from \"./util.js\";\n\ntype B = Builder<Scene, [\"foo\", \"bar\"]>;\n\ntype bar1 = ExpandRecursively<B>;\ntype bar2 = Expand<B>;\n\ntype Expand<T> = T extends infer O ? { [K in keyof O]: O[K] } : never;\n\ntype ExpandRecursively<T> = T extends object\n  ? T extends infer O\n    ? { [K in keyof O]: ExpandRecursively<O[K]> }\n    : never\n  : T;\n\ntype ExpandPartialScene = Expand<PartialScene2>;\ntype ExpandRecursivelyPartialScene = ExpandRecursively<PartialScene2>;\n\n/*\n  List\n  for item in List:\n    item = Pick<T, item>\n\n*/\n\nfunction run() {\n  let scene: ExpandRecursivelyPartialScene = { foo: {} };\n  // scene.foo = {};\n  scene = { ...scene, bar: {} };\n  scene = { ...scene, baz: {} };\n  // let scene2: Scene = scene;\n}\n// {\n//   type Tail<T extends unknown[]> = ((...args: T) => never) extends (\n//     _: any,\n//     ...args: infer R\n//   ) => never\n//     ? R\n//     : never;\n\n//   type X = Tail<[1, 2, 3]>;\n// }\n"]}